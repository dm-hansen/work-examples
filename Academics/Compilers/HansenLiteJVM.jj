PARSER_BEGIN(HansenLite)

import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Stack;
import java.util.HashMap;

/**
 * Defines the HansenLite language and provides parsing and a VM for
 * execution
 */
public class HansenLite
{
   // A couple of class variables that define the name and version of
   // the language
   private final static String _VERSION = "1.0";
   private final static String _LANGUAGE_NAME = "HansenLite";
   private final static String _DESCRIPTION = _LANGUAGE_NAME+" Parser Version "+_VERSION;


   // Output file
   private static PrintWriter _OUTPUT_FILE = null;

   // Counter used to create unique begin/end labels
   private static int _NEXT_LABEL_NUM = 0;

   // Stack used to keep track of the current label context for code
   // generation
   private static Stack<Integer> _LABEL_STACK = new Stack<Integer>();

   // Map of defined variable names 
   private static HashMap<String, Symbol> _SYMBOL_TABLE = new HashMap<String, Symbol>();



   /******************************
    * Parse the program in the given file, writing Java assembly to the
    * output file
    * 
    * @param args first element contains optional filename to compile
    */
   public static void main (String args[]) throws RuntimeException
   {
      // A parser instance
      HansenLite parser = null;

      // If insufficient command-line arguments then display error and
      // exit
      if (args.length < 2)
      {
         System.err.println(_DESCRIPTION+":\n  Usage: java HansenLite <inputFile> <outputFile>");
         System.exit(1);
      } 

      // Try to open the source file using the first argument 
      try 
      {
         parser = new HansenLite(new java.io.FileInputStream(args[0]));
      }
      catch(java.io.FileNotFoundException e)
      {
         System.err.println(_DESCRIPTION+":  File " + args[0] + " not found.");
         System.exit(1);
      }

      // Now try to open the output file using the second argument 
      try 
      {
         _OUTPUT_FILE = new PrintWriter(args[1]+".j");
      }
      catch(java.io.IOException e)
      {
         System.err.println(_DESCRIPTION+":  Error opening " + args[1] + ".j for ouptput.");
         System.exit(1);
      }

      // Output the preamble to the output file
      _OUTPUT_FILE.println(".class public "+args[1]+"\n.super java/lang/Object\n.method public <init>()V\naload_0\ninvokenonvirtual java/lang/Object/<init>()V\nreturn\n.end method\n.method public static main([Ljava/lang/String;)V\n.limit locals 10\n.limit stack 10");


      // Parse the source. Parse errors will terminate the
      // parsing by throwing a ParseException; catch those, display,
      // and exit
      try 
      {
         // The Statement production is the start of the
         // grammar. So begin there and see if we can successfully
         // parse the input
         parser.Statement();
         System.out.println("Success!");
      }
      catch(ParseException e) // Parse error?
      {
         System.err.println(_DESCRIPTION+":  Encountered errors during parse.");
         System.err.println(e);
         System.exit(1);
      } 

      // Terminate the main method and we're done.
      _OUTPUT_FILE.print("return\n.end method");
      // Close the output file
      _OUTPUT_FILE.close();

   } //main



   /**
    * Symbol for holding user-defined names. We'll fill the Symbol table
    * with these objects for each variable declared. No need to make
    * things public/private or create methods, we're all friends here...
    */
   static class Symbol
   {
      /**
       * @param object is the type of token
       * @param location is the local variable number
       */
      Symbol(Token object, int location)
      {
         _object = object;
         _location = location;
      }
      Token _object;
      int _location;
      public String toString(){return _object.image+" @location: "+_location;}
   }
   

   /**
    * Print the code to the output file
    *
    * @param code is the code to print
    */
   public static void emit(String code)
   {
      _OUTPUT_FILE.println(code);
   }

   
   /*********************************************************************************
                                Semantic Actions
   *********************************************************************************/
 
   /**
    * Emit code to store top of program stack to the variable named by the 
    * token
    */
   public static void store(Token variable) throws ParseException
   {
      if (!_SYMBOL_TABLE.containsKey(variable.image))
         throw new ParseException("Encountered undeclared variable '"+
              variable.image+"' at line "+variable.beginLine+
              ", column "+variable.beginColumn);

      emit("istore "+_SYMBOL_TABLE.get(variable.image)._location);
   }

   /**
    * Emit code to load the variable onto the program stack. Throw an
    * exception if it's not been declared
    */
   public static void load(Token variable) throws ParseException
   {
      if (!_SYMBOL_TABLE.containsKey(variable.image))
         throw new ParseException("Encountered undeclared variable '"+
              variable.image+"' at line "+variable.beginLine+
              ", column "+variable.beginColumn);

      emit("iload "+_SYMBOL_TABLE.get(variable.image)._location);
   }

   /**
    * Load the constant number onto the program stack
    */
   public static void load_int(Token value)
   {
      emit("ldc "+value.image);
   }

   /**
    * Load the constant string on top of the variable stack onto the program stack
    */
   public static void load_string(Token value)
   {
      emit("ldc "+value.image);
   }

   /**
    * Compute the operation
    */
   public static void compute(Token operation)
   {
      switch (operation.kind)
      {
         case HansenLiteConstants.SUB_OP:
            emit("isub"); break;
         case HansenLiteConstants.ADD_OP:
            emit("iadd"); break;
         case HansenLiteConstants.MULT_OP:
            emit("imul"); break;
         case HansenLiteConstants.DIV_OP:
            emit("idiv"); break;
         // For logical operations, we emit code that tests for the
         // opposite condition (e.g., for <= we test > and if true, jump
         // to the "end" label.
         case HansenLiteConstants.LE_OP:
            emit("if_icmpgt end"+_LABEL_STACK.peek()); break;
         case HansenLiteConstants.GE_OP:
            emit("if_icmplt end"+_LABEL_STACK.peek()); break;
         case HansenLiteConstants.NE_OP:
            emit("if_icmpeq end"+_LABEL_STACK.peek()); break;
         case HansenLiteConstants.LT_OP:
            emit("if_icmpge end"+_LABEL_STACK.peek()); break;
         case HansenLiteConstants.GT_OP:
            emit("if_icmple end"+_LABEL_STACK.peek()); break;
         case HansenLiteConstants.EQ_OP:
            emit("if_icmpne end"+_LABEL_STACK.peek()); break;
      }
   }

   /**
    * Negate the top of the program stack if the operator is '-'
    */
   public static void sign(Token sign)
   {
      // If this is a negation sign, then negate the value on the stack
      if (sign.kind == HansenLiteConstants.SUB_OP)
         emit("ineg");
   }

   /**
    * Add a variable or constant atop the operand stack to the symbol
    * table 
    */
   public static void declare(Token object)
   {
      // Add a new variable to the symbol table whose location is based on 
      // the number of other variables already declared
      _SYMBOL_TABLE.put(object.image, new Symbol(object, _SYMBOL_TABLE.size()+1));
   }

   /**
    * Emit code to push System.out onto the program stack
    */
   public static void print_header()
   {
      emit("getstatic java/lang/System/out Ljava/io/PrintStream;");
   }

   /**
    * Emit code to print an integer
    */
   public static void print_ifooter()
   {
      emit("invokevirtual java/io/PrintStream/print(I)V");
   }

   /**
    * Emit code to print a string
    */
   public static void print_sfooter()
   {
      emit("invokevirtual java/io/PrintStream/print(Ljava/lang/String;)V");
   }

   /**
    * Increment the next label number to maintain context for generating labels
    */
   public static void gen_labels()
   {
      _LABEL_STACK.push(++_NEXT_LABEL_NUM);
   }

   /**
    * Pop the current label context off the label stack
    */
   public static void pop_labels()
   {
      _LABEL_STACK.pop();
   }

   /**
    * Emit "goto" to the current label
    */
   public static void goto_begin()
   {
      emit("goto begin"+_LABEL_STACK.peek());
   }

   /**
    * Emit "goto" to the current begin label
    */
   public static void goto_end()
   {
      emit("goto end"+_LABEL_STACK.peek());
   }

   /**
    * Emit a begin label
    */
   public static void begin_label()
   {
      emit("begin"+_LABEL_STACK.peek()+":");
   }

   /**
    * Emit an end label
    */
   public static void end_label()
   {
      emit("end"+_LABEL_STACK.peek()+":");
   }

} // HansenLite


PARSER_END(HansenLite)






/***********************************************************************************
                             Language Definitiion
***********************************************************************************/


/******************
 * TOKENS and LEXEMES
 ******************/

/* Whitespace, including comments */
SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"{" (~["}"])* "}">
}

/* Constants */
TOKEN : {
   <#DIGIT: ["0"-"9"]> 
|  <#LETTER: ["A"-"Z","_","a"-"z"]> 
|  <NUMBER : <DIGIT> (<DIGIT>)*> 
|  <STRING_CONST : "\"" (~["\""])* "\"">
}

/* Reserved words and identifiers */
TOKEN : {
   <VAR: "variable">
|  <PRINT: "print">
|  <IF: "if">
|  <THEN: "then">
|  <ELSE: "else">
|  <WHILE: "while">
|  <DO: "do">
|  <BEGIN: "begin">
|  <END: "end"> 
|  <STATEMENT_SEP: ";"> 
|  <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
}

/* Individual operators */
TOKEN : {
   <ASSIGN_OP: ":=">
|  <ADD_OP: "+">
|  <SUB_OP: "-">
|  <MULT_OP: "*">
|  <DIV_OP: "/">
|  <LE_OP: "<=">
|  <GE_OP: ">=">
|  <NE_OP: "<>"> 
|  <LT_OP: "<">
|  <GT_OP: ">">
|  <EQ_OP: "=">
}

/******************
 * GRAMMAR
 ******************/


// Statements are assignments, if, while, print, variable declaration,
// or a block-of-statements
void Statement() : {}
{
   AssignmentStatement() 
|  IfStatement() 
|  WhileStatement() 
|  PrintStatement()
|  DeclarationStatement()
|  Block() 
}

// A variable declaration is the keyword "variable" followed by the name of a variable 
void DeclarationStatement() : {}
{
   <VAR> <IDENTIFIER> 
        { declare(token); } 
}

void AssignmentStatement() : { Token variableName; }
{
   <IDENTIFIER> 
        { variableName = token; } 
   <ASSIGN_OP> Expression() 
        { store(variableName); }
}

// A block of code
void Block() : {}
{
   <BEGIN> StatementList() <END>
}

// Statement list is statement followed by more statements
void StatementList() : {}
{
   Statement() [ SeparatedList() ]
}

// Separated list is a separater followed by a statement then another
// separated list
void SeparatedList() : {}
{
   <STATEMENT_SEP> Statement() [ SeparatedList() ]
}

void IfStatement() : {}
{
   <IF> 
           { gen_labels(); }
      BooleanExpression()  
      <THEN>
      Statement() 
           { goto_begin(); end_label(); }
      [ LOOKAHEAD(2) ElseClause() ] 
           { begin_label(); pop_labels(); }
}

void ElseClause() : {}
{
   <ELSE> Statement()
}

void WhileStatement() : {}
{
   <WHILE> 
           { gen_labels(); begin_label(); }
      BooleanExpression() 
      <DO>
      Statement() 
           { goto_begin(); end_label(); pop_labels(); }
}

void PrintStatement() : {}
{
   <PRINT>
        { print_header(); }
   PrintExpression()
}


void BooleanExpression() : { Token operator; }
{
   Term() 
      ( <LT_OP> | <GT_OP> | <LE_OP> | <GE_OP> | <NE_OP> | <EQ_OP> )
           { operator = token; }
      Term()
           { compute(operator); }
}

void PrintExpression() : {}
{
   Expression()
        { print_ifooter(); }
|  <STRING_CONST> 
        { load_string(token); print_sfooter(); }
}

void Expression() : { Token operator; }
{
   MultiplicativeTerm() 
   [ ( <ADD_OP> | <SUB_OP> ) 
            { operator = token; }
       Expression() 
            { compute(operator); }
    ]
}

void MultiplicativeTerm() : { Token operator; }
{
     SignedTerm() 
     [ ( <MULT_OP> | <DIV_OP> ) 
             { operator = token; }
         MultiplicativeTerm() 
             { compute(operator); }
     ]
}

void SignedTerm() : { Token operator = null; }
{
   [ <ADD_OP> | <SUB_OP>  
        { operator = token; }
   ] 
   Term()
        { if (operator != null) sign(operator); }
}

void Term() : {}
{
   "(" Expression() ")"
|  <IDENTIFIER>
     { load(token); }
|  <NUMBER> 
     { load_int(token); }
}






